20.1 Introduction
The creation of partitions can be accomplished either during the installation process or at any time after the installation is complete. Typically, users find that creating the partitions during the installation is easier because most installation programs provide a GUI-based program, while the technique to create partitions after the installation is typically a CLI-based program.

Additionally, the installation program will automatically create a filesystem for the new partition as well as configure it to be mounted automatically during the boot process. When creating a partition after the installation, these steps must be manually executed by the administrator.

However, there are some cases in which the system administrator may want to create partitions post-install. For example, the system administrator may not have access to all resources during the installation. This could happen when a second hard drive is added to the system at a later date.

The installation program, while easier, also doesn't provide as much flexibility in how the partition or filesystem is created. The CLI-based commands that can be used post-install are much more powerful and flexible, providing another benefit to waiting until after the installation to create any additional partitions.

It is important to note that some partitions need to be created during the installation process to provide a location to install the operating system files. As a result, post-install partitions are typically created for non-system critical features, such as a place to store additional software or to store a large database.

##########################################################################################################################################
##########################################################################################################################################
20.2 Creating Partitions During Installation
The installation process can vary quite a bit from one distribution to another. In the examples provided, the screen captures are from the CentOS 6.5 installer program named Anaconda.

One step of the installation process essentially asks: How much of the hard drive space should be used to install the operating system?

Select installation type window. Options include; Use All Space, Replace Existing Linux System(s), Shrink Current System, Use Free Space, Create Custom Layout (this option is selected).
When choosing one of these options, the following should be taken into consideration:

Use All Space: Use this option when there is no need to save any data from the existing hard drive. This option will remove all traces of any previous hard drive data, including previous installations of other operating systems.

Replace Existing Linux Systems: Use this option when the system is a dual boot system, typically a system with both a Linux operating system and a Microsoft Windows operating system. Realize that all Linux operating systems will be replaced by this new installation. However, the Microsoft Windows operating system should not be impacted.

Shrink Current System: This option would be used to recover hard drive space from an existing Linux operating system. The recovered space could then be used to install a second Linux operating system for a dual boot system. This is an advanced installation method, and all data from the existing Linux operating system should be backed up prior to using this method.

Use Free Space: This option assumes that a previous operating system (Microsoft Windows or Linux) has already been installed and there is still unpartitioned space available on the hard drive. This is usually the case when creating a dual boot system as Microsoft Windows should be installed first without using all of the hard drive space. The remaining space is used by the Linux Installer to install the Linux operating system.

Create Custom Layout: This option is used for advanced installations. The administrator is provided with the opportunity to remove existing partitions and create new partitions to meet the needs of the customized installation.
If the Create Custom Layout option is chosen, the distribution installer will provide a graphical tool for creating partitions, such as the following:

Add Partition window. Mount Point is /, File System Type is ext 4, Allowable Drives is sad, Size (MB) is 1000, Additional Size Options is Fill all space up to 1200 MB.
Components of this graphic:

Mount Point: The directory where the filesystem for this partition will be mounted.

File System Type: The type of filesystem to place on this partition. The exact types that will be available during the installation will depend on what specific Linux operating system is being installed.

Allowable Drives: This area provides a list of available hard drives. If only one hard drive is present, then it is greyed out. If multiple hard drives are present, then the individual who is performing the installation can choose which hard drive to place this partition on.

Size (MB): The size in megabytes of the partition. Note that this relates to the next field.

Additional Size Options:

Fixed Size: The partition will be the size specified by the Size (MB) field.

Fill all space up to (MB): The partition will be at least the size specified by the Size MB field but can be as large as this field. For example, if the Size (MB) field is 500, and the Fill all space up to (MB) field is 800, then partition size will be between 500MB and 800MB. This is useful when the individual that is performing the installation creates partitions, and there is extra space left over. The installer will automatically take this extra space and assign it to partitions that make use of this field.

Fill to maximum allowable size: The partition will be at least the size specified by the Size (MB) field. Any additional unpartitioned space will be given to this partition. If multiple partitions have this option, the unpartitioned space is divided equally between these partitions.

To better understand the Additional Size Options fields, consider the following scenarios:

Scenario #1
Hard Drive: 2400 MB

Mount Point	Size	Additional Size
Partition 1	/	1000 MB	Fixed Size
Partition 2	/var	500 MB	Fixed Size
Partition 3	/home	200 MB	Fixed Size
Three Add Partition windows side-by-side. In the first window (left to right); / is 1000MB, in the second window /var is 500 MB and in the third window /home is 200 MB.
Result:
/ is 1000MB
/var is 500MB
/home is 200MB
700MB of space is unused
Scenario #2
Hard Drive: 2400 MB

Mount Point	Size	Additional Size
Partition 1	/	1000 MB	Fill all space up to 1200 MB
Partition 2	/var	500 MB	Fixed Size
Partition 3	/home	200 MB	Fixed Size
Three Add Partition windows side-by-side. In the first window (left to right); / is 1200MB, in the second window /var is 500 MB and in the third window /home is 200 MB.
Result:

/ is 1200MB
/var is 500MB
/home is 200MB
500MB of space is unused
Scenario #3
Hard Drive: 2400 MB

Mount Point	Size	Additional Size
Partition 1	/	1000 MB	Fill all space up to 1200 MB
Partition 2	/var	500 MB	Fill to maximum allowable size
Partition 3	/home	200 MB	Fill to maximum allowable size
Three Add Partition windows side-by-side. In the first window (left to right); / is 1200MB, in the second window /var is 750 MB and in the third window /home is 450 MB.
Result:

/ is 1200MB
/var is 750MB
/home is 450MB
Consider This

To boot to both Windows and Linux, the system administrator should install Windows first and then Linux. This is necessary because the bootloader (the program that boots the system) for Windows can't boot Linux, but the bootloader for Linux can boot Windows.

Consumer-based systems that are purchased in a store will already have Windows installed, but it will be using the entire disk. In the Windows Control Panel, Administrative Tools folder, find the Computer Management tool, which can be used to manage partitions within the Windows operating system. If Windows is using the entire disk, use this tool to shrink the partition that Windows is using, to make space for a Linux installation.

Many Linux distributions will also query the user during installation on an existing Windows disk scheme and allow for the shrinking of the Windows partition to leave room for Linux partitions.


##########################################################################################################################################
##########################################################################################################################################
20.3 Creating Partitions After Installation
Originally, hard disks were called fixed disks because they were not removable. Coincidentally, the most common command line tool for editing the partition tables on disks is called fdisk. This command can be used to create, modify, and list the partitions on a hard drive.

One of the benefits of the fdisk tool is that it is very forgiving; if a mistake is made while using the tool, simply quit the program, and nothing will be changed on the system. Only when changes are written (saved) before quitting will the program update the partition table.

The fdisk program can be used in two ways: interactive and non-interactive. The interactive mode is used to modify the partitions, and the non-interactive mode is used to list partitions. In either mode, the fdisk program requires root privileges to run.

A couple of options can affect the output of the program when working with it in either mode. The units option -u will list the starting and ending locations for each partition in sectors instead of cylinders. Since Linux technically partitions by sector, it may be beneficial to use this option. If cylinders are used, the fdisk utility will translate into sectors, so using the -u option is only really required for fine tuning of partition sizes and to avoid seeing the following error message, highlighted below:

root@localhost:~# fdisk -l /dev/sda
Disk /dev/sda: 11.3 GB, 11261706240 bytes
255 heads, 63 sectors/track, 1369 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000ee7d2

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          64      512000   83  Linux
Partition 1 does not end on cylinder boundary.
/dev/sda2              64        1306     9972736   Linux LVM
/dev/sda3           1306        1319     102400   82  Linux swap / Solaris
Partition 3 does not end on cylinder boundary.
‌⁠​​⁠​ 
Consider This

On almost every Linux distribution, the default fdisk output is displayed in cylinders. One exception is Ubuntu, which displays output in sectors by default. To display the output in cylinders, use the -u=cylinders option.

When using the fdisk utility, a warning will occur by default:

Warning
DOS-compatible mode is deprecated.  It's strongly recommended to switch off the mode and change the display units to sectors.
The -c option disables the warning regarding compatibility issues with the MS-DOS operating system. Although it is very unlikely that compatibility with this operating system will be an issue since DOS has not been available as a product for nearly twenty years, a warning will be issued if the -c option is not used.



##########################################################################################################################################
##########################################################################################################################################
20.3.1 Displaying Partitions
To use fdisk in its non-interactive mode, add the -l option. To demonstrate, the following command will display a list of all partitions of all hard disk devices:

root@localhost:~# fdisk -cul
Disk /dev/sda: 21.5 GB, 21474836480 bytes
255 heads, 63 sectors/track, 2610 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000571a2

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        2481    19921920   83  Linux
/dev/sda2            2481        2611     1046529    5  Extended
/dev/sda5            2481        2611     1046528   82  Linux swap / Solaris
It isn't critical that you understand the entire output of this command. The following describes the key components of the output that a system administrator should understand in order to manage partitions effectively:

Device Info

Disk /dev/sda: 10.7 GB, 10737418240 bytes
The device name and size of the device in bytes.

Columns

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        2481    19921920   83  Linux
/dev/sda2            2481        2611     1046529    5  Extended
/dev/sda5            2481        2611     1046528   82  Linux swap / Solaris
Device	The specific partition that the row is describing. For example, /dev/sda1 is the first partition on the first SATA hard drive.
Start	The starting sector of the partition.
End	The ending sector of the partition.
Blocks	The size of the partition in blocks.
Id	An identifier which is used to tell the kernel what type of filesystem should be placed on this partition. For example, the value 83 indicates that this partition should have an ext2, ext3, or etx4 filesystem type.
System	A human-readable name that indicates the type of filesystem the Id column refers to. For example, 83 is a Linux filesystem.
To see the partitions of a specific hard disk, add the pathname for the disk as an argument to the previous command.

Note

The example below may not match the output in our virtual environment.

root@localhost:~# fdisk -c=dos -u=sectors -l /dev/sdb
Disk /dev/sdb: 505 MB, 505413632 bytes
5 heads, 52 sectors/track, 3796 cylinders, total 987136 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x7f08b2c3

   Device Boot  	Start     	End  	Blocks   Id  System
/dev/sdb1        	2552  	987135  	492292	6  FAT16
Note

The partition table described above is stored permanently in the MBR. When the system is booted, a copy is created in memory. This copy is used by the kernel for various system tasks. The kernel can't look directly at a filesystem to determine what type it is. So, the partition table stores this information for the benefit of the kernel. When the partition is created, it is the responsibility of the system administrator to indicate what type of filesystem will be placed on that partition by providing the partition type.

The commands used to create the filesystems are covered in greater detail later in the chapter.

Consider This

A useful tip for using fdisk in interactive mode is that a copy of the output of the fdisk -l command can be sent to a file on disk. Anyone who has ever made a mistake when partitioning a disk and needs to refer to the previous setup will appreciate having a copy of the exact cylinders and filesystems to refer to.

root@localhost:~# fdisk -l /dev/sda > mydisklayout.txt



##########################################################################################################################################
##########################################################################################################################################
20.3.2 fdisk Interactive Mode
In the interactive mode, a system administrator can use the fdisk command to create and modify partitions. To enter the interactive mode, do not use the -l option, but still use -c and -u options. The pathname for the disk to edit is required. For example, to edit the partitions for the first SATA /dev/sda hard drive, execute the following command to display a prompt:

Note

The following examples may not match the output in our virtual environment.

root@localhost:~# fdisk -cu /dev/sda
Command (m for help):
The m command will display a menu or help screen:

Command (m for help): m

Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)
Before creating any partitions, it is a good idea to print the partition table by choosing the p command action. Note that this doesn't really send output to a printer, but to the screen instead. The output will look very much like the output of the fdisk -l command.

Command (m for help): p

Disk /dev/sda: 11.3 GB, 11261706240 bytes
255 heads, 63 sectors/track, 1369 cylinders, total 21995520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000ee7d2

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    20971519     9972736   8e  Linux LVM
Note that based on the output from the previous command, there is some unpartitioned space on the /dev/sda device. The ending sector of the last partition /dev/sda2 is 20971519, and the /dev/sda device has a total of 21995520 sectors. This means that there are 1024001 sectors that haven't been partitioned. Given that a sector is 512 bytes, 1024001 sectors is approximately 500MB.



##########################################################################################################################################
##########################################################################################################################################
20.3.3 Creating Partitions
In order to create a new partition, the n command action should be chosen:

Command (m for help): n
This command will prompt the system administrator to answer several questions, as described below.

Type of Partition

Command Action
   e   extended
   p   primary partition (1-4)
The choices that are available to answer this question will vary, depending on what partitions already exist:‌⁠​​⁠​ 

If no extended partition has been created, the choices will be e for an extended partition or p for a primary partition.
If the extended partition has been created, the fdisk utility will automatically create a logical partition within the free space of the extended partition.
Recall that there can be only four primary partitions or three primary partitions with one extended. If there are already three existing primary partitions, be very careful; while there is nothing wrong with making the fourth partition a primary partition, per se, this will result in not being able to create any additional partitions. Additionally, if the fourth partition doesn't make use of the remaining free space on the hard drive, that space will go to waste.

The best choice is to create an extended partition if there are already three primary partitions. For this extended partition, allocate all of the remaining free sectors. Then, logical partitions can be created within the extended partition.

Partition Number

Partition number (1-4): 3
When creating a primary partition, the fdisk utility will prompt for a partition number. Again, it is helpful to display the partition table to identify what the last partition number was and a numeric value of one higher. For example, if the last partition number was 2, then the next partition should be numbered 3.

When creating logical partitions, the fdisk utility will not prompt for a partition number and will assign a number by default.

Starting Sector

First sector (20971520-21995519, default 20971520):
The next question asks where to start the new partition. Allocating this first sector should be extremely easy because the fdisk utility knows which sector is the next available. Pressing the Enter key accepts this value.

First sector (20971520-21995519, default 20971520):
Using default value 20971520
It is possible to type the sector number, but this is generally not recommended, as it may create unusable ranges of sectors.

Partition Size

Last sector, +sectors, or +size{K,M,G} (20971520-21995519, default 21995519):
The last question asks what size the partition should be. There are three different techniques for assigning the last sector: last sector, +sectors, or +size:

Using the last sector technique can be the hardest because there are a couple of calculations required. Sectors of a disk are generally 512 bytes in size, so to make a new 100 MB partition requires approximately 200,000 sectors. To calculate the last sector, add 200,000 to the value of the starting sector. Typically, the last sector technique is only used to utilize the rest of the available space. In that case, accept the default value by pressing the Enter key:

Last sector, +sectors, or +size{K,M,G} (20971520-21995519, default 21995519):
Using default value 21995519
Using the +sectors technique takes one less calculation than the last sector technique. With this technique, calculate the number of sectors needed and prefix it with the + plus sign. For example, to create a partition that is approximately 100MB, enter the value as +200000:

Last sector, +sectors, or +size{K,M,G} (20971520-21995519, default 21995519): +200000
The final technique +size is normally preferred since no calculations are needed. Use the + plus sign, the size to make the partition, and a suffix to indicate the unit. For example, to specify the 100 MB size partition, enter the value for the ending sector as +100M:

Last sector, +sectors, or +size{K,M,G} (20971520-21995519, default 21995519): +100M
The following is an example of an interaction with fdisk to create a new 100 MB partition using these steps:

The current partition table is displayed with the p command.
The n command indicates a new partition is being created.
The user enters p to create a primary partition.
The partition is assigned as number 3.
The default value for the first sector is chosen by pressing the Enter key.
For the size, the user chooses +100M for a one-hundred-megabyte partition
Command (m for help): p

Disk /dev/sda: 11.3 GB, 11261706240 bytes
255 heads, 63 sectors/track, 1369 cylinders, total 21995520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000ee7d2

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    20971519     9972736   8e  Linux LVM

Command (m for help): n
Command Action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 3
First sector (20971520-21995519, default 20971520):
Using default value 20971520
Last sector, +sectors, or +size{K,M,G} (20971520-21995519, default 21995519): +100M
After creating a partition, verify that it was correctly created by displaying the partition table:

Command (m for help): p

Disk /dev/sda: 11.3 GB, 11261706240 bytes
255 heads, 63 sectors/track, 1369 cylinders, total 21995520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000ee7d2

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    20971519     9972736   8e  Linux LVM
/dev/sda3        20971520    21176319      102400   83  Linux
When verifying this data, pay close attention to the Start and End sectors. Notice in the previous output that the starting sector of the /dev/sda3 partition is one value higher than the ending sector of the /dev/sda2 partition. Any overlap would result in data loss and should be avoided.

No changes have been made to the MBR, so it is possible to quit now in the event that any errors are displayed in the new partition table. To quit without saving changes, use the q command.

Warning

The fdisk command is a destructive partitioning tool. Any changes to your partition structure may overwrite existing partition information and make data inaccessible.

In the next example, a fourth partition is added as an extended partition, and then two logical partitions are created within the extended partition. Notice that once the extended partition has been created, the fdisk utility skips the first two steps, since the partition is automatically designated as logical and assigned a number.

Command (m for help): n
Command Action
   e   extended
   p   primary partition (1-4)
e
Partition number (1-4): 4
First sector (21176320-21995519, default 21176320):
Using default value 21176320
Last sector, +sectors, or +size{K,M,G} (21176320-21995519, default 21995519):
Using default value 21995519
Command (m for help): n
First sector (21178368-21995519, default 21178368):
Using default value 21178368
Last sector, +sectors, or +size{K,M,G} (21178368-21995519, default 21995519): +100M
Command (m for help): n
First sector (21385216-21995519, default 21385216):
Using default value 21385216
Last sector, +sectors, or +size{K,M,G} (21385216-21995519, default 21995519):
Using default value 21995519
Notice that the logical partitions use starting and ending sectors that are within the extended partition:

Command (m for help): p

Disk /dev/sda: 11.3 GB, 11261706240 bytes
255 heads, 63 sectors/track, 1369 cylinders, total 21995520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000ee7d2

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    20971519     9972736   8e  Linux LVM
/dev/sda3        20971520    21176319      102400   83  Linux
/dev/sda4        21176320    21995519      409600    5  Extended
/dev/sda5        21178368    21383167      102400   83  Linux
/dev/sda6        21385216    21995519      305152   83  Linux
Delete partitions by using the d command. Be careful to avoid deleting necessary existing partitions, as this may result in an unusable system.



##########################################################################################################################################
##########################################################################################################################################
20.3.4 Changing the Filesystem Type
By default, the fdisk utility sets the filesystem type to Id 83 (Linux) for primary and logical partitions. For extended partitions, the Id should be 5 and should never be changed.

To change the filesystem type, use the t command:

Command (m for help): t
The fdisk utility will prompt for the number of the partition to be changed:

Partition number (1-6): 6
Lastly, the user will be prompted to enter a hexadecimal value for the Id. In the following example output, the user enters a value of 82, which changes the partition Id to Linux swap/Solaris:

Hex code (type L to list codes): 82

Changed system type of partition 6 to 82 (Linux swap / Solaris)
While at the Hex Code prompt, the user can display a list of the hex codes that are available by typing the L character:

Hex code (type L to list codes): L

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris
 1  FAT12           39  Plan 9          82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      3c  PartitionMagic  83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       40  Venix 80286     84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      41  PPC PReP Boot   85  Linux extended  c7  Syrinx
 5  Extended        42  SFS             86  NTFS volume set da  Non-FS data
 6  FAT16           4d  QNX4.x          87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS       4e  QNX4.x 2nd part 88  Linux plaintext de  Dell Utility
 8  AIX             4f  QNX4.x 3rd part 8e  Linux LVM       df  BootIt
 9  AIX bootable    50  OnTrack DM      93  Amoeba          e1  DOS access
 a  OS/2 Boot Manag 51  OnTrack DM6 Aux 94  Amoeba BBT      e3  DOS R/O
 b  W95 FAT32       52  CP/M            9f  BSD/OS          e4  SpeedStor
 c  W95 FAT32 (LBA) 53  OnTrack DM6 Aux a0  IBM Thinkpad hi eb  BeOS fs
 e  W95 FAT16 (LBA) 54  OnTrackDM6      a5  FreeBSD         ee  GPT
 f  W95 Ext'd (LBA) 55  EZ-Drive        a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            56  Golden Bow      a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    5c  Priam Edisk     a8  Darwin UFS      f1  SpeedStor
12  Compaq diagnost 61  SpeedStor       a9  NetBSD          f4  SpeedStor
14  Hidden FAT16 <3 63  GNU HURD or Sys ab  Darwin boot     f2  DOS secondary
16  Hidden FAT16    64  Novell Netware  af  HFS / HFS+      fb  VMware VMFS
17  Hidden HPFS/NTF 65  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE
18  AST SmartSleep  70  DiskSecure Mult b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 75  PC/IX           bb  Boot Wizard hid fe  LANstep
1c  Hidden W95 FAT3 80  Old Minix       be  Solaris boot    ff  BBT
1e  Hidden W95 FAT1
There are technically dozens of filesystem types as demonstrated by the previous output. However, only a handful of these filesystems can realistically be used on a Linux operating system. Many of the filesystems that are listed in the previous graphic are older. Each Linux distribution can support different filesystems as this is actually a feature of the kernel, so it is best to look at the system's documentation to determine which filesystem types work on a particular distribution.

In the following example, the /dev/sda6 partition is changed to 82, a swap partition, using the same steps described above.

Command (m for help): t
Partition number (1-6): 6
Hex code (type L to list codes): 82
Changed system type of partition 6 to 82 (Linux swap / Solaris)
It is always a good idea to double-check the new Id by printing the partition table:

Command (m for help): p

Disk /dev/sda: 11.3 GB, 11261706240 bytes
255 heads, 63 sectors/track, 1369 cylinders, total 21995520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000ee7d2

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    20971519     9972736   8e  Linux LVM
/dev/sda3        20971520    21176319      102400   83  Linux
/dev/sda4        21176320    21995519      409600    5  Extended
/dev/sda5        21178368    21383167      102400   83  Linux
/dev/sda6        21385216    21995519      305152   82  Linux s



##########################################################################################################################################
##########################################################################################################################################
20.3.5 Saving Changes
If the changes that have been made to the in-memory partition table are correct, commit changes to disk with w, followed by Enter. The fdisk utility will write the in-memory changes to the actual MBR and exit. However, it is also possible to quit the fdisk utility without making any changes to the disk by using the q command.

Note the following possible error after saving changes:

The partition table has been altered!

Calling iotctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The table will be used at the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
This error is the result of the kernel being unable to read the new partition table into memory from the MBR, something that the ioctl() function is responsible for. As mentioned in the output of this error, the partprobe or kpartx command can be executed to fix this issue if these commands are installed on the system. If not, then the system will need to be rebooted before the new partitions can be used.



##########################################################################################################################################
##########################################################################################################################################
20.3.6 The sfdisk Command
There is a scriptable fdisk-like program called sfdisk. Not only can this program be used to automate partitioning, it is also capable of backing up and restoring the current partition table.

To back up the partition table, first, determine the names of the disk devices. The sfdisk command will list the disk(s) and their sizes when provided the -s option. If the system contained only one 500 GB disk, then the output of the command may appear something like the following, with the pathname of the device and its size:

Note

The following examples may not match the output in our virtual environment.

root@localhost:~# sfdisk -s
/dev/sda:   500088608
Before partitioning the disk, it would be a good idea to back up the current partition table data by using the -d option to the sfdisk command:

root@localhost:~# sfdisk -d /dev/sda > sda.disk
In the event that a mistake is made while using partition editing tools, the partition table can be restored to the original partition table by executing the sfdisk command with the -f option:

root@localhost:~# sfdisk -f /dev/sda < sda.disk
Beware that using the wrong file may corrupt the partition table, which could result in a total loss of data.

##########################################################################################################################################
##########################################################################################################################################
20.4 Managing GPT
Some hard drives make use of a partitioning technology called Master Boot Record (MBR) while others make use of a partitioning type called GUID Partitioning Table (GPT). The MBR type of partitioning has been used since the early days of the personal computer (PC), and the GPT type has been available since the year 2000.

The GPT disks use a newer type of partitioning, which allows the user to divide the disk into more partitions than what MBR supports. GPT also allows having partitions, which can be larger than two terabytes (MBR does not). The tools for managing GPT disks are named similarly to the fdisk counterparts: the gdisk, cgdisk, and sgdisk programs.

##########################################################################################################################################
##########################################################################################################################################
20.4.1 Managing GPT
To create and manage GPT partitions from the command line, you can use the gdisk utility, also called GPT fdisk. It operates in a similar fashion to fdisk except it operates on GPT partitions and requires the device to be specified in order to work.

sysadmin@localhost:~$ sudo gdisk /dev/sdb1
GPT fdisk (gdisk) version 1.0.3

Partition table scan:
MBR: not present
BSD: not present
APM: not present
GPT: not present

Creating new GPT entries.

Command (? for help): ?
b	back up GPT data to a file
c	change a partition's name
d	delete a partition
i	show detailed information on a partition
l	list known partition types
n	add a new partition
o	create a new empty GUID partition table (GPT)
p	print the partition table
q	quit without saving changes
r	recovery and transformation options (experts only)
s	sort partitions
t	change a partition's type code
v	verify disk
w	write table to disk and exit
x	extra functionality (experts only)
?	print this menu
When you specify a blank disk, it will scan the device and report back no partition information. Typing a question mark ? character returns a list of command options available, type n to add a new partition.

Command (? for help): n
Partition number (1-128, default 1):
First sector (34-62529502, default = 2048) or {+-}size{KMGTP}:
Last sector (2048-62529502, default = 62529502) or {+-}size{KMGTP}:
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300):
Changed type of partition to 'Linux filesystem'
It returns information about the new partition that was just created; you can also type p to print the partition table information.

Command (? for help): p
Disk /dev/sdb1: 62529536 sectors, 29.8 GiB
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): 78F1C87E-5159-4AD8-89BA-A5F79B854835
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 62529502
Partitions will be aligned on 2048-sector boundaries
Total free space is 2014 sectors (1007.0 KiB)

Number Start (sector) End (sector) Size Code Name
1 2048 62529502 29.8 GiB 8300 Linux filesystem
The v command will verify the partition to ensure it is free from errors.

Command (? for help): v

No problems found. 2014 free sectors (1007.0 KiB) available in 1
segments, the largest of which is 2014 (1007.0 KiB) in size.
The o command allows you to create a new empty partition; it verifies that you want to delete existing partitions before proceeding.

Command (? for help): o
This option deletes all partitions and creates a new protective MBR.
Proceed? (Y/N): y
The p command again prints information about the new partition.

Command (? for help): p
Disk /dev/sdb1: 62529536 sectors, 29.8 GiB
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): 4876B7C5-0ADB-4281-AA77-A3FFAEC5F2AF
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 62529502
Partitions will be aligned on 2048-sector boundaries
Total free space is 62529469 sectors (29.8 GiB)

Number Start (sector) End (sector) Size Code Name
The w command writes the partition data to the disk and will exit. Once again, it verifies that you want to proceed with overwriting (deleting) the existing partitions.

Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sdb1.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot or after you
run partprobe(8) or kpartx(8)
The operation has completed successfully.

##########################################################################################################################################
##########################################################################################################################################
20.5 GNU Parted
So far, you have learned to use the fdisk and gdisk commands to create, list, and delete partitions. Another available tool for creating and resizing partitions on a hard drive is the GNU Parted program. The GNU Parted program includes the parted command line tool and the gparted graphical interface tool. One benefit of using GNU Parted is that unlike the gdisk and fdisk tools, which are destructive partitioners, GNU Parted will non-destructively resize a partition as well as the filesystem on top of it.

The parted program can be used in two ways: command line mode and interactive mode. When using parted in either mode, a device must be specified. To do this, the following syntax must be used:

parted DEVICE
The DEVICE argument is used to specify the hard drive to modify, for instance, /dev/sdb. If this argument is not used, a default device will be chosen for you, or an error message may be displayed. To use parted in command line mode, the DEVICE argument must be followed by options to create or modify a partition. To see a list of options available for parted, use the --help option:

root@localhost:~# parted --help
Usage: parted [OPTION]... [DEVICE [COMMAND [PARAMETERS]...]...]
Apply COMMANDs with PARAMETERS to DEVICE.  If no COMMAND(s) are given, run in
interactive mode.

OPTIONs:
  -h, --help                      displays this help message
  -l, --list                      lists partition layout on all block devices
  -m, --machine                   displays machine parseable output
  -s, --script                    never prompts for user intervention
  -v, --version                   displays the version
  -a, --align=[none|cyl|min|opt]  alignment for new partitions

COMMANDs:
  align-check TYPE N                        check partition N for TYPE(min|opt)
        alignment
  help [COMMAND]                           print general help, or help on
        COMMAND
  mklabel,mktable LABEL-TYPE               create a new disklabel (partition
        table)
  mkpart PART-TYPE [FS-TYPE] START END     make a partition
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all|NUMBER]     display the partition table,
        available devices, free space, all found partitions, or a particular partition
  quit                                     exit program
  rescue START END                         rescue a lost partition near START
        and END
  resizepart NUMBER END                    resize partition NUMBER
Output Omitted...
Note

Traditional short and long options, such as -l or --list, must be used when using parted in command line mode.

To view the disks on the system, use the lsblk command:

root@localhost:~# lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda    8:0    0 3.7T  0 disk
|-sda1 8:1    0 512M  0 part
|-sda2 8:2    0 3.5T  0 part /etc/hosts
`-sda3 8:3    0 128G  0 part [SWAP]
sdb   8:16    0 20G  0  disk
The sdb disk noted in the output above is the target device for the partitioning examples below. It is an empty disk that is the second device on the IDE device bus.

Next, to view any existing partition information with the parted command, use the following:

root@localhost:~# parted /dev/sdb print
Model: ATA VMware Virtual I (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table:
Disk Flags:

Number  Start  End  Size  Type  File system  Flags
Note in the output above, that there is no partition information listed on the /dev/sdb device, as it’s currently blank.

To make the disk partitionable, a disklabel (partition table) must be created. This is done with the following command:

root@localhost:~# parted /dev/sdb mklabel msdos
You may need to update the /etc/fstab
Note

If a disk has an existing partition table, the command may query the user about overwriting the current partition table, and in that case, the user would type the Y key and then press Enter.

Now that a partition table is written to the disk, partitions can be created on the disk. To create a primary partition that takes up the first 50% of the disk, use the following command:

root@localhost:~# parted /dev/sdb mkpart primary 0% 50%
You may need to update the /etc/fstab
Once the command executes, the user can verify the partition was created with the command:

root@localhost:~# parted /dev/sdb print
Model: ATA VMware Virtual I (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table:
Disk Flags:

Number  Start    End      Size    Type     File system  Flags
1       1049kB   10.7GB   10.7GB  primary
While it is possible to format the resulting partition with a filesystem during the parted mkpart process, experience has indicated that the partitioning process is best done by parted and the creation of a filesystem by the appropriate mkfs command.

At this point, 3 more primary partitions can be written to the disk or an extended partition that encompasses the rest of the space and then logical partitions inside that.

The parted utility’s interactive mode can also be used to create or resize partitions. To begin using interactive mode, simply use the parted command with a device argument to specify the drive:

root@localhost:~# parted  /dev/sdb
GNU Parted 3.2
Using /dev/sda
Welcome to GNU Parted! Type ‘help to view a list of commands.
(parted)
Note in the example above that the prompt will change to (parted). The h command will display a menu or help screen:

(parted) h
  align-check TYPE N                        check partition N for TYPE(min|opt) alignment
  help [COMMAND]                           print general help, or help on COMMAND
  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)
  mkpart PART-TYPE [FS-TYPE] START END     make a partition
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all|NUMBER]     display the partition table, available devices,
 free space, all found partitions, or a particular partition
  quit                                     exit program rescue START END rescue a lost
 partition near START and END
  resizepart NUMBER END                    resize partition NUMBER
  rm NUMBER                                delete partition NUMBER
  select DEVICE                            choose the device to edit
  disk_set FLAG STATE                      change the FLAG on selected device
  disk_toggle [FLAG]                       toggle the state of FLAG on selected device
  set NUMBER FLAG STATE                    change the FLAG on partition NUMBER
  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition NUMBER
  uni5 UNIT				      set the default unit to UNIT
  version				      display the version number and copyright information of Gnu Parted
Notice that many of the commands used in command line mode such as the mkpart, mklabel, and print commands are available in the interactive mode. The process of creating and modifying partitions using parted in interactive mode is similar to using fdisk or gdisk in interactive mode.

##########################################################################################################################################
##########################################################################################################################################
20.5.1 gparted
Modern systems which use the Unified Extensible Firmware Interface (UEFI) specification and GPT partitions to boot have their own graphical and command line tools for managing storage. One powerful graphical tool is the gparted tool, the GUI front end of the GNU Parted program. Gparted (Gnome Partition Editor) is a free, multi-platform graphical tool for managing hard disks. It works with Linux, Windows, and MacOS and allows the creation, reorganization, and deletion of system partitions. With this tool, you can resize existing partitions to make space for a new operating system, enable and disable partition flags like boot and hidden, and perform many other partitioning tasks easily with its intuitive graphical interface.

In the image below, we have a blank disk that needs to be partitioned and a filesystem created on it before it can be used (mounted) onto the system. Partitioning defines the space on the device so that it is visible to the operating system. Then, a high-level format is performed, which defines the filesystem to be used. Finally, the filesystem is mounted so that data can be written to it by the operating system.

Gparted window for /dev/sdb. The /dev/sdb disk shows 29.82 GiB of unallocated space.
Using the gparted utility, we can create a new GPT partition table. There are several methods that can be used when creating a table. For example, a common partitioning method is making space on an existing disk to install another operating system by resizing the existing partition. In addition to performing disk management tasks, the gparted tool can also attempt recovery on a corrupted partition, and copy an existing partition for backup or image creation.

GParted window. Dropdown menu shows mouse selecting gpt option.
Parameters for the new partition can be entered into the dialog box such as size, name, whether it’s a primary partition (where an operating system can be installed), and filesystem type.

Create new Partition window. Settings show that Free space preceding is 1 MiB, New size is 30533 MiB, Free space following is 0 MiB, Align to MiB, Create as is Primary Partition, File system is ext 4.
To see details about the partition to be created, you would select device information from the View menu. In the image below, at the bottom of the window, you can see there is one operation pending. When you click the green checkmark below the menu bar, it will perform the specified action and create the new partition. There will be a dialog confirming that you want to proceed with the action, and one confirming success.

GParted window shows new gpt Partition #1 29.82 GiB created on /dev/sdb. The text 1 operation pending appears on the bottom left of the window.


##########################################################################################################################################
##########################################################################################################################################
20.6 Logical Volume Management
Logical Volume Management (LVM) is a method of managing hard disk space that provides more flexibility than traditional partitioning of disks. LVM was developed specifically to address some of the limitations of traditional partitioning. To understand this, consider the following scenarios:

Scenario #1
Synopsis: A system administrator performs a fresh installation of what will become a production machine. The administrator chooses to implement the following partitioning scheme: / is 2000MB, /var is 500MB, and /home is 1000MB.

The intent behind this partitioning scheme was to provide plenty of space for the four users who will be using the system. By making /home a separate partition, the administrator is also able to implement disk quotas.

The Problem: For the first few months, the system performs perfectly. However, errors start to occur. Users are unable to print. After some research, the administrator discovers that the /var partition is now full of log file entries. Unfortunately, this is also where print jobs are sent prior to being sent to the printer.

The obvious solution is to make the /var partition bigger. With traditional partitions, this can be a nightmare that may require downtime for the system and perhaps even a reinstallation. One of the great benefits of LVM is the ability to increase the size of the partition, referred to as a volume in LVM, as needed without the necessity for system downtime.

Scenario #2
Synopsis: A system administrator adds two new hard drives to the system. One hard drive is 40GB and the second is 20GB. The requirements for this system are to place a very large database on a single partition that is at least 60GB in size. This isn't possible with traditional partitions in this scenario because a partition must reside on a single hard drive.

With LVM, a volume (think partition) can span over multiple hard drives. This provides a great deal more flexibility over traditional partitions and is necessary for today's big data environments.

Scenario #3
Synopsis: A system administrator wants to back up the data in the /home partition. In order to get a clean backup, all users must be signed off the system, and the /home partition needs to be unmounted, resulting in downtime. This is due to the way that filesystem backup programs work: they back up the filesystem metadata first, then back up the file contents. With a live filesystem, changes to files during the backup results in possibly corrupted backups that may be worthless.

The solution is to make use of a feature called an LVM snapshot. An administrator can use this snapshot to back up a filesystem that will appear to be static, but won't require any system downtime.

Note

Logical Volume Management is a wide and varied topic, and a complete discussion is well beyond the scope of this class. The focus of this section will be to cover Logical Volume Management to the extent of possible LPIC-1 exam questions.

Understanding what Logical Volume Management is, the advantages of Logical Volume Management over traditional partitioning, and basic Logical Volume Management is necessary not only for a junior system administrator but also for anyone taking the LPIC-1 exam.


##########################################################################################################################################
##########################################################################################################################################
20.6.1 LVM Concepts
The steps to implement LVM include the following:

Connect the physical devices to the system.

Use pvcreate to convert the desired devices into physical volumes, which will allocate them for inclusion in the LVM scheme. This will write a header to the physical device and make them visible to the LVM process.

Use vgcreate to incorporate all of the desired physical volumes into a virtual collection called a volume group. The volume group now will act as a multi-disk equivalent of a physical volume on which partitioning can occur.

Use lvcreate to create the LVM version of disk partitions (called logical volumes) in the volume group created previously. The logical volumes act like partitions in that the user can create filesystems on them, mount them, and in general use them as a traditional partition.
The main advantages of using LVM in general and logical volumes, in particular, is the ability to group together space from multiple physical devices, resize them (as well as the filesystems on them), and much more.

To develop a better understanding of how these steps work, consider a situation in which three new hard drives are added to the system: /dev/sdb, /dev/sdc, and /dev/sdd.

Three cylinder shapes side-by-side depicting hard drives. The first from left is the /dev/sdb drive, the second is the /dev/sdc drive and the third is the /dev/sdd drive.
At this point, they are just three hard drives that don't have anything on them, including a partition table. To use these as part of LVM, first execute the pvcreate command on each one:

root@localhost:~# pvcreate /dev/sdb
root@localhost:~# pvcreate /dev/sdc
root@localhost:~# pvcreate /dev/sdd
Three cylinder shapes side-by-side depicting Physical Volumes. The first from left is the /dev/sdb volume, the second is the /dev/sdc volume and the third is the /dev/sdd volume.
Initially, these hard drives won't appear to be any different. However, there is now a small block of data, called a header, in the very beginning of each that defines each device as a physical volume.

The next step is to create a volume group that consists of these three physical volumes. This can be accomplished with the following command:

root@localhost:~# vgcreate vol1 /dev/sdb /dev/sdc /dev/sdd
Three cylinder shapes side-by-side depicting Physical Volumes. The first from left is the /dev/sdb volume, the second is the /dev/sdc volume and the third is the /dev/sdd volume. Underneath is a large cylinder shape depicting a Volume Group labeled vol1.
What this now means, is that all of the space from all three physical volumes can be used to create logical volumes. If /dev/sdb is 50GB, /dev/sdc is 20GB, and /dev/sdd is 10GB, a single logical volume could be created that is 80GB in size. Additionally, if another physical volume was added to the system (add a new hard drive, use the pvcreate command, and then a command called vgextend), then this new space could be used to create more logical volumes or add to the size of existing logical volumes.

Any of the space in the vol1 volume group can be used to create a logical volume with a command like the following:

root@localhost:~# lvcreate -L 200M -n logical_vol1 vol1
The -L option is used to specify the size of the logical volume. The value of 200M means create a 200MB logical volume. The -n option is used to provide a name to the logical volume. The resulting name of the logical volume created by the previous command will be logical_vol1. The last argument, vol1, is the name of the volume group from where the logical volume will obtain its physical space. The previous lvcreate command would result in a new device name of /dev/vol1/logical_vol1 that could be used just like a traditional partition.

Three cylinder shapes side-by-side depicting Physical Volumes. The first from left is the /dev/sdb volume, the second is the /dev/sdc volume and the third is the /dev/sdd volume. Underneath is a large cylinder shape depicting a Volume Group labeled vol1. Underneath the Volume Group is a cylinder shape depicting a Logical Volume labeled /dev/vol1/logical_vol1.
For Red Hat-based systems, the graphical tool system-config-lvm not only simplifies the process of working with LVM, it also helps to visualize what is happening:

Logical Volume Management window. Window shows logical view and physical view of a volume group.
Keep in mind that this tool may not be available as it is not part of the base operating system, but may be part of an optional add-on software package.


##########################################################################################################################################
##########################################################################################################################################
20.7 Creating a Filesystem
If the fdisk command is used to create a partition, then the filesystem will have to be created separately.

The mkfs command can be used to create a filesystem. To make a vfat type filesystem, which is compatible with multiple operating systems, including Microsoft Windows, execute the command like the following:

root@localhost:~# mkfs -t vfat /dev/sdb1
The mkfs command is a wrapper that executes another command, which will actually make the correct filesystem. When provided the -t vfat option, the mkfs command will call the mkdosfs command to make the actual filesystem. This is important to know because the mkfs command provides generic options while the underlying command may have options specific to the filesystem that it creates. Consult the documentation, such as the man pages, to see these additional options.

A very common filesystem is the Fourth Extended Filesystem, ext4, the default filesystem on many Linux distributions. To create this type of filesystem, execute a command like the following:

root@localhost:~# mkfs -t ext4 /dev/sdb1
In this case, the mkfs command would end up calling the mke2fs command, which is capable of creating ext2, ext3, and ext4 type filesystems.

Note

When creating a filesystem, the partition is written to, so previously held data on the partition will be lost. As a result, be very careful when executing the mkfs command.

Fortunately, the mkfs command will not work if the partition is currently in use, meaning it's mounted.

Each filesystem has many options to modify features about the filesystem. To use these options, execute the filesystem creation command directly, rather than the mkfs command.

For example, the mke2fs command has several options that will modify how the filesystem will behave after it has been created. Some of these features can be changed after the filesystem has been created, but others cannot. The following table describes a few of the common features that a system administrator may change for ext2/etx3/ext4 filesystems:

Option	Description
-b	Specifies the block size of the filesystem. While the default is typically fine for normal filesystems, for filesystems with large databases, a larger block size is more ideal.
-N	
Specifies the number of inodes. Recall that each file needs an inode, so this value is an important one. By default, the mke2fs command uses a formula based on filesystem size to determine how many inodes to create.

Typically, this generates a huge number of inodes, which on filesystems with only a handful of large files results in wasted spaces since these inodes take space even if they are not in use.

The number of inodes can't easily be changed after the filesystem has been created.
-m	
Specifies what percentage of the filesystem is reserved for system use. Consider the partial output of the df command shown below:

Filesystem  Size  Used  Avail Use% Mounted on
/dev/sda2   485M  114M  346M  25%  /
There appears to be something wrong with this output. If 114M of a 485M filesystem is used, then there should be 368M available, not 346M! Also, the Use%, which displays how much space has been used, is inaccurate. It should be closer to 23%.

The reason why these numbers are inaccurate is that 5% of the filesystem is reserved for system use. Regular users can't use this space, so it is considered to be unavailable; as a result, the df command takes that into consideration when reporting available space.

To specify a different percentage of reserved space, use the -m option. This is a useful option for filesystems that the root user doesn't typically use, like the /home filesystem.

The df command will be covered in greater detail later in the course.
Consider This

The mkfs command will create the appropriate filesystems for all, except ISO 9660 and Universal Disc Format. ISO 9660 is the format placed on CD-ROM discs and Universal Disc Format is used to format DVDs. To create an ISO 9660 filesystem, use the mkisofs command. In order to create a Universal Disc Format filesystem, use the mkudffs command.


##########################################################################################################################################
##########################################################################################################################################
20.8 exFAT
The exFat (Extended File Allocation Table) filesystem is a proprietary, lightweight filesystem created by Microsoft in 2006 for use with flash memory storage systems like SD cards and USB thumb drives. It was designed to replace the FAT32, and it greatly expands the amounts allowed for files and directories. Linux does not natively support exFAT, and when trying to access data on devices formatted with it, users will be shown an error dialog box like this one.

Error message window with text stating Unable to access USB30FD.
Fortunately, Samsung published a GPL driver for exFat so Linux users can share data with the other operating systems which support it such as Windows 10 and MacOS.

To demonstrate how to install the necessary packages in order to access the exFat drive, consider the image below, which shows a 63gb USB drive with the Ubuntu Disks application.

Drive window showing Volumes. The volumes are depicted as a rectangle showing 115MB of free space and 63gb 63 GB exFAT partition on /dev/sdc.
From the command line, you will need to make sure the proper repository, in this case, the universe repository, is installed. To ensure that the repository is installed, the add-apt command can be used. In the example below, the output of the add-apt command establishes that the repository is already present on the system. However, if it was not, the add-apt command could be used to install it:

sysadmin@localhost:~$ sudo add-apt-repository universe
[sudo] password for sysadmin:
'universe' distribution component is already enabled for all sources.
Note

A repository is a collection of data stored on a server. In Linux, repositories are used to store system updates and applications that can be downloaded.

The add-apt command is part of the Advanced Package Tool (APT) used for package management.

Repositories and package management are covered in greater detail later in the course.

Next, the apt update command can be used to confirm that everything in the repository is up-to-date:

sysadmin@localhost:~$ sudo apt update
Hit:1 http://us.archive.ubuntu.com/ubuntu cosmic InRelease
Get:2 http://us.archive.ubuntu.com/ubuntu cosmic-updates InRelease [88.7 kB]
Get:3 http://us.archive.ubuntu.com/ubuntu cosmic-security InRelease [88.7 kB]
Hit 4: http://us.archive.ubuntu.com/ubuntu cosmic-backports InRelease
Fetched 177 kB in 1s (139 kB/s)
Reading package lists… Done
Building dependency tree
Reading state information… Done
11 packages can be upgraded. Run ‘apt list —upgradable’ to see them.
Next, the needed exfat-fuse and exfat-utils packages will need to be installed using the apt install command.

Lastly, mount the drive (this step can also be done from the file manager).




##########################################################################################################################################
##########################################################################################################################################
20.9 BTRFS
BTRFS (sometimes pronounced b-tree FS or butter FS) is a Linux native filesystem created by Oracle and developed by multiple companies as well as many individual contributors to address the limitations of previous filesystems.

Copy-On-Write
BTRFS is a copy-on-write (COW) system. While a complex technical feature, the main point of copy on write is that BTRFS will not overwrite an existing file with updates, which traditional non-COW filesystems do routinely.

For example, if you have a file named datafile1.txt and you make updates to the file’s contents, on a traditional non-COW filesystem, the file would be overwritten with the new data, making retrieval of the original version of the file something that could only be done by restoring from backup. Instead of BTRFS overwriting datafile1.txt, it will leave that file in place, untouched, and writes the new or changed portions of the file elsewhere, and then changes the file’s metadata to encompass the change.

Copy-on-write is one reason why BTRFS has a significant advantage of recovery time from hardware failure, power outage, or other forms of catastrophe. The original version of the file will remain intact, and continue to be available even as follow-on versions or changes are written elsewhere. This has the added benefit of acting as a journal of sorts because transactions (updates) are either completed or not, and if not, the already written to disk portions of the file are safe and sound on disk.

Snapshots
BTRFS’s use of copy-on-write also makes snapshots possible and very useful to the system operator. A traditional snapshot is effectively a filesystem/volume copy that is made and time-stamped. BTRFS does this differently, it declares a reference to the original as a snapshot and if nothing is changed, effectively takes no additional space.

When a change is made after a snapshot, the changes are noted and logged, but only that change is actually made as a copy, all of the rest of the filesystem does not need to be copied too. This is a tremendous space-saving measure, allowing the use of snapshots for even the smallest changes to be something that will not cause space issues.

To demonstrate, suppose that after installation, the system operator performs a snapshot of the filesystem/volume and then creates the datafile1.txt file. The initial snapshot does not include the datafile1.txt file, but a second or subsequent snapshot would. Therefore, a comparison of the first and second snapshots would show that the only difference between them is the addition of the datafile1.txt file.

Traditional cloning, backups or even some implementations of snapshots would copy all or some of the original filesystem or volume, but a BTRFS snapshot uses the original filesystem as a base, and subsequent snapshots only contain the differences between the original state and the previous snapshot, thus making snapshots extremely efficient on space.

Subvolumes
Another very important feature of BTRFS is its volume management, which is handled by the BTRFS volume manager. Those familiar with Logical Volume Manager, or LVM, will understand the basic concept of BTRFS being able to base its volumes/filesystems on multiple physical devices. Any volume can be based on one or more physical disks, and can also contain subvolumes, which are effectively portions of a volume that are used as a virtual disk.

Consider This

Virtual storage is represented logically. Logical computing basically means represented as software rather than hardware. The reason for creating logical storage is that it can be merged together to create one large storage pool. To get from hardware to software, the physical storage capacity from all the storage devices needs to be pooled together to form one large virtual disk.

One of the main areas where subvolumes can be helpful is in the application of updates to a system. To do this, a subvolume is created that encompasses the main volume, the updates are applied, then the system is inspected for any issues with the updates, and if no issues are found, everything continues on as normal. If any issues are found, the system updates can be rolled back to the original volume’s state.

Compression
BTRFS also features compression options that can be turned on via mounting options, with the compress option using several levels or types, or no compression at all. There is even a compression option that will force compression of file types that do not compress well. It’s important to note that compression typically takes at least a minimal amount of processing to accomplish, so extremely large filesystems with hard-to-compress files will produce more system load than usual.

As you move forward in your learning, it will become clear that Linux is an ever-changing system being improved and modified as needs arise. Partitions and filesystems are no exception, in fact, they are rapidly evolving, even as you progress through this course. Each system improves on the last, and a strong understanding of prior systems is needed not only for fundamental knowledge but also because Linux systems can operate for years or even decades. Accomplished system administrators will be called on to maintain, troubleshoot, and migrate older systems to newer technologies as business needs evolve.


##########################################################################################################################################
##########################################################################################################################################
20.10 Creating Swap Space
Consider a situation in which a system has a total of 8GB of RAM. Initially, this system functions properly, however, as time goes on and new software is added to the system, Insufficient RAM errors start occurring. Running out of usable RAM has been an issue for operating systems since RAM was first introduced.

While the best solution might be to add more RAM to the system, this isn't always possible. Hardware limitations or budget constraints may necessitate another solution. Swap space is designed to provide a solution to this problem.

Swap space (also called virtual memory) is hard drive space that can be used by the kernel and memory management routines to store data that is normally stored in RAM. When RAM starts to become full, the kernel will take some of this data and swap it to the hard drive. At a later time, as it’s needed, the data will be swapped back to RAM.

Even if the system has plenty of RAM, creating a swap space is still useful because if the system ever crashes, swap space is used to store a crash dump file which is used by advanced system administrators to determine why the system crashed. As a result, typically the size of the swap space is at least equal to the size of RAM.

Consider This

The rule of “swap space should be equal to RAM” works up to a point; however, there is much discussion about what to do when a system has a very large amount of RAM as it seems wasteful to dedicate 128, 256, or 512 GB of disk space to swap.

It is best to research the distribution vendor or organizer’s recommended amounts of swap space. The major supported distributions will have support and recommendations for swap amounts in their documentation.

There are two types of swap spaces that can be created:

Swap Partition: The more common of the two, a swap partition is a partition that doesn't have a regular filesystem on it, and is not mounted. During installation, a swap partition is created, but additional swap partitions can be created at a later time.

Swap File: In the event that there is no unpartitioned space left on the hard drive, a swap file can be used. Swap partitions are typically faster than swap files as they are a filesystem, not a file, that is located on top of another filesystem. Swap files are more flexible and can be created on the fly without the need to repartition the hard drive.


##########################################################################################################################################
##########################################################################################################################################
20.10.1 Creating a Swap Partition
The steps to creating a swap partition are:

Create a partition with an Id of 82 using fdisk as previously described:

Command (m for help): n
Command Action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 3
First sector (20971520-21995519, default 20971520):
Using default value 20971520
Last sector, +sectors, or +size{K,M,G} (20971520-21995519, default 21995519): +100

Command (m for help): t
Partition number (1-6): 3
Hex code (type L to list codes): 82
Changed system type of partition 3 to 82 (Linux swap / Solaris)
Convert the partition to swap space with the mkswap command.

root@localhost:~# mkswap /dev/sda3
Setting up swapspace version1, size = 102396 KiB
no label, UUID=59aaf06e-7109-471f-88a5-e81dd7c82d76
Enable the partition as current swap space with the swapon command:

root@localhost:~# swapon /dev/sda3
‌⁠​​⁠​ 
The -s option to the swapon command will display currently used swap space:

root@localhost:~# swapon -s
Filename                                Type            Size    Used    Priority
/devdm-1                                partition       1015800 0       -1
/dev/sda3                               partition       102392  0       -2
Note

The swapon command only temporarily enables a swap partition. If the system is rebooted, the swap partition will still exist, but it will not be enabled as swap space. The administrator needs to either execute the swapon command again or make use of a mounting feature that is demonstrated later in the course.


##########################################################################################################################################
##########################################################################################################################################
20.10.2 Creating a Swap File
The steps to create a swap file:

Create a large file using the dd command. In order to determine which filesystem has room for the swap file, the df command was executed. The / filesystem has plenty of room, so the swap file was placed in the /var directory:

root@localhost:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda9        58G  7.7G   49G  14%
tmpfs           7.9G     0  7.9G   0% /dev
shm              64M     0   64M   0% /dev/shm
/dev/sda9        58G  7.7G   49G  14% /etc/hosts
root@localhost:~# dd if=/dev/zero of=/var/extraswap bs=1M count=100
100+0 records in
100+0 records out
104857600 bytes (105 MB) copied, 0.320096 s, 328 MB/s
Note that the resulting file is approximately 100MB in size, 100 blocks of 1MB in size. The options bs=100M and count=1 would have resulted in the same size. The file is full of binary zero values that came from the /dev/zero file. What is actually in the file doesn't really matter; the size of the file is what is important.

Convert the file to swap space with the mkswap command:

root@localhost:~# mkswap /var/extraswap
Setting up swapspace version 1, size = 102396 KiB
no label, UUID=908e51f8-a022-4508-8819-73e1d8837e2b
Enable the file as current swap space with the swapon command:

root@localhost:~# swapon /var/extraswap
root@localhost:~# swapon -s
Filename                                Type            Size    Used    Priority
/devdm-1                                partition       1015800 0       -1
/dev/sda3                               partition       102392  0       -2
/var/extraswap                          file            102392  0       -3



##########################################################################################################################################
##########################################################################################################################################
